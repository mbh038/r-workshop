---
title: "Use of ggplot for plotting"
author: "Your Name"
date: "the date"
output:
  html_document:
    df_print: paged
---

In this exercise we are going to use the package `ggplot` which is part of the `tidyverse` package and can be used to produce a variety of commonly used plots. 

You will see that the code to do each plot is very similar, whatever the type of plot, and that plots can be built up from very basic forms to become really attractive, informative versions with very little additional effort.

You need to read the example in the accompanying worksheet and fill in the missing code in the empty code chunks below, or alter what is provided already.

Remember that this is a markdown document, so you can add extra text between the chunks, to explain what is going on. You can format it too, if you wish, according to the very basic markdown rules for doing this. For these rules see Help/Markdown Quick Reference.

### Load packages
```{r}
# install.packages("name of package") # run this line once, if you need to, if either package needs to be installed

# enter code to load the tidyverse and palmerpenguins packages 
```

### Load the palmer penguin data

The `palmerpenguin` package contains two built-in data sets. One is called `penguins`
```{r}
# enter code to load the penguins data set and then inspect it
```

How many rows are there, how many columns?

For more detailed meta-information on the data:
```{r}
# enter code to get help information on this data set
```



### Summary stats on all the numeric columns
```{r}
# enter code to get summary descriptive statistcs for all the columns in the data set
```

We see that there are some rows with NAs in for a few of the columns. These are how R represents what would be missing values in an Excel spreadsheet.  We need to be aware of this when doing calculations wih the data, such as taking means.

Here , we will remove those rows:

### Remove the rows with NAs
```{r}
# this is how we remove any row that has missing data - NAs.
penguins <- penguins %>%
  drop_na()
```


### How many observations are there for each species?

Note the use of the pipe operator `%>%`, here and throughout. Think of it as meaning `and then`. It deeds the outtput of one line into the function of the next line, where it is used as that function's first argument.

```{r}
penguins %>%
  count(species)
```

### Mean value for each numerical variable, for each species
```{r}
penguins %>%
  group_by(species) %>%
  summarize(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  ungroup()
```

### Is flipper length correlated with body mass?

We could a do correlation test to find this out, but let us first plot the data. We will show here how an elegant plot is built up, starting from a very basic one, so that you see what eac hline of code for the finished version actually does. In the chunks below, run each one in turn to see the effect of adding each successive line.

First we feed the penguin data to the function `ggplot()`, and tell it which variables are to be 'mapped' to which aesthetic (which means, roughly speaking, 'visible') features of the plot, such as the x-axis, the y-axis, point and line colours, fill colours, symbol types and size etc:

```{r which variables}
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=body_mass_g))
```

This produces the first layer of the eventual finished plot, an empty plot, ready to receive data. Before it can display the data, `ggplot()` needs to be told *how* you want to do that - what type of plot do you want? For that, we add a `geom.....()` line, to specify the type of plot.

There are lots of geom types, but for a scatter plot we use `geom_point()`:

```{r scatter plot}
# add a geom... line of code to give a scatter plot
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=body_mass_g)) +

```

This gives us a recognisable scatter plot, but it is defficient in a number of ways. We know there are threee species of neguin. It would be better if each plotted using a different colour. We can do this by adding in an extra argument to the aesthetic in the first line:

```{r scatter plot by species}
# modify. the first line to make each species appear in a different colour
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=body_mass_g)) +
  geom_point()
```

Now we add labels, titles and so on, using the line `labs(...)`. You can write the arguments for this over several lines on the page, for clarity:

```{r add labels and titles}
# add a labs() line to produce suitable axis labels, and title and subtitle for the plot
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=body_mass_g,colour=species)) +
  geom_point()

```

Now we use a `theme` to alter the overall look of the figure. There are several built-in themes you can choose from, and others from packages that you can use. I usually use `theme_cowplot()` from the `cowplot` package. Try typing `?theme` at the command prompt in the console window to see what is available. In the worksheet , we used the built-in `theme_bw()`. Try that here, but also try others that take your fancy:

```{r add theme}
# add a theme_bw() line to give the plot a different overall look
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=body_mass_g,colour=species)) +

```

Now reposition the legend. We don't have to, but we might not like the default position of the legend, If not, we can move it using another `theme()` line. The position argument can be "top", "bottom", "left", "right" or a numerica vector in relative coordinatees, where c(0,0) means bottom left within the plot, and c(1,1) means top-right. This is what we use here. Play around with different values.

```{r place the legend}
# add a theme line to reposition the legend
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=body_mass_g,colour=species)) +

```

Nicer colours. If you don't like the default colours offered by R, there are several other palettes available, for example the `Brewer` palettes, borrowed from the world of maps. See https://colorbrewer2.org and  for a list of the available palettes, type >`?scale_colour_brewer` into the console pane then look at the help that appears in the Help pane (bottom right), and scroll down to the palettes section. Note that we dont *have* to alter the colours. But doing so can make your plots look nicer. For an assignment or dissertation report, it is a good idea to pick a palette that you like and that works, and stick with it, so that all your plots have the same general look. Try the qualitative palette `"Set2"`, then play with a few others and see what you get. You do this by adding the line `scale_colour_brewer(palette="Set2")`

```{r nicer colours}
# add a scale_colour_brewer() line to get a different palette of colours. Try "Set2"
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=body_mass_g,colour=species)) +
  geom_point() +

```


If we like, we can add best fit lines to each subset of the data, using `geom_smooth()`. To produce straight line fits, `geom_smooth()` needs to be told to use a linear model, using the `method = "lm"` argument. By default, you will get lines with a grey 95% condidence band around them. This can be useful, but if you don't want it, add the argument `se = FALSE`. You can also alter the linewidth.

```{r add best fit lines}
# add a geom_smooth(method = "lm", linewidth = 0.5, se = FALSE) line to add best fit lines for each species
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=body_mass_g,colour=species)) +
  geom_point() +

```

### Repeat for bill length and flipper length

Modify the code of the previous plot so that you now plot bill length vs flipper lengh. Adjust any labels and titles as necessary. This time, put the legend in the bottom right of the plot.

```{r bill length vs flipper length}
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=bill_length_mm,colour=species)) +
  geom_point() +
  geom_smooth(method="lm", linewidth=0.5,se=FALSE) + # try leaving out the se argument
  labs(x = "Flipper length (mm)",
       y = "Bill length (mm)",
       colour= "Species",
       title="Penguin size, Palmer Station LTER",
       subtitle="Flipper length and bill length for Adelie, Chinstrap, and Gentoo Penguins") +
   scale_colour_brewer(palette="Set2") +
  theme_bw() +
  theme(legend.position = c(0.9,0.2)) # play with the values to get it where you want it
```

Do you see how straightforwrd it is to adapt the code that produces one plot to get the code you need for another, similar plot?

### Add yet more informtion to the plot

Let us include the information of which island the penguins come from by making the shape of the plotted points be dependent on that:

```{r islands and species}
# modify the first line so that different symbols are used to denote the island where the penguins were observed: hint: add a shape = species argument to the aesthetic in the first line
penguins %>%
  ggplot(aes(x=flipper_length_mm,y=bill_length_mm, colour = species)) +
  geom_point() +

```

### Distribution of penguin flipper lengths

#### Histogram

First, a basic histogram
```{r basic histogram}
penguins %>%
  ggplot(aes(x=flipper_length_mm)) +  # why is y not specified?
  geom_histogram()
```

Now colour this by species and add labels, theme etc, jsut as we have done before:
```{r hist for each species}
# add lines to include axis labels, a title and change the theme to theme_bw()
penguins %>%
  ggplot(aes(x=flipper_length_mm,fill=species)) +
  geom_histogram() +
  labs(x = "Flipper length (mm)",
       y = "Count",
       fill= "Species",
       title="Penguin flipper lengths") +
  scale_fill_brewer(palette="Set2") +
  theme_bw() +
  theme(legend.position = "right") # play with the position to get it where you want it
```

Annoyingly, it is difficult to make each histogram semi transparent, so that the ones at the back are not obscured by the ones in the front. An alternative to a histogram, the density plot, implemented by `geom_density()` allows us to do this, using the argument `alpha`, where `alpha = 0` means transparent and `alpha = 1` means fully opaque.

A density plot is like a smoothed histogram.

#### Density plot
```{r density}
penguins %>%
  ggplot(aes(x=flipper_length_mm,fill=species)) +
  geom_density(alpha=0.2) +
  labs(x = "Flipper length (mm)",
       y = "Density",
       fill= "Species",
       title="Penguin flipper lengths") +
  scale_fill_brewer(palette="Set2") +
  theme_bw() +
  theme(legend.position = "right") # play with the position to get it where you want it
```

#### Box plot of flipper lengths for each species

Box plots are a really useful way to summarise numerical response data such as `flipper_length_mm`  across different categorical variables, such as `species`. We use `geom_boxplot()` to produce them


```{r box plot basic}
penguins %>%
  ggplot(aes(x=species,y=flipper_length_mm,fill=species)) +
  geom_boxplot()
```

Now add lines to 

* include suitable axis labels and a title
* give the same 'theme' ie overall look as the previous graphs
* fill the boxes with a different colour for each species. Does this actually convey extra information? 
* remove the legend that you now have, bcuase you don't need it (Why?). Use `theme(legend.position="none")` to do this.

```{r box plot improved}
penguins %>%
  ggplot(aes(x=species,y=flipper_length_mm,fill=species)) +
  geom_boxplot() +

```


#### Violin Plot using `geom_violin()`

This is a variant on the box plot. Each 'violin' is a sideways plot of the distribution of the data for each species, with its own mirror image. The code for them is exactly as for box plots except the we use `geom_violin()`.

```{r violin basic}
penguins %>%
  ggplot(aes(x=species,y=flipper_length_mm,fill=species)) +
  geom_violin() 
```

Now write code to improve this, just as you did the box plot. The code is the same as for that apart from one line!
```{r violin improved}
penguins %>%
  ggplot(aes(x=species,y=flipper_length_mm,fill=species)) +
  geom_violin() +

```

#### Ridge plot

This is a variant on the density plot, that is most useful when you have lots of categorical variables. We have only three here, the three penguin species, but let's try it anyway.

For this, we need the `ggridges` package. This is one of many packages that extend the power of ggplot, and so work in much the same way:

```{r}
# library
#install.packages("ggridges") # use this once, if you have to, then comment it out.
library(ggridges) 
 
# basic example
penguins %>%
ggplot(aes(x = flipper_length_mm, y = species, fill = species)) +
  geom_density_ridges() +
  labs(x = "Flipper length (mm)",
       y = "Species",
       title="Penguin flipper lengths") +
  theme_ridges() + 
  theme(legend.position = "none")

```

Now try producing graphs like the ones above, but for body mass rather than flipper length.

### Bar chart with error bar

There are different ways to produce this commonly used way to summarise data. For example we might use one to compare the mean flipper lengths of the different penguin species. For a bar chart of these to be of any use at all, it needs to include error bars that show standard errors of the means (Why?). 

I usually first create a summary of the data, in which we calculate the means and standard error of the mean for each species for whatever variable I am inerested in, then feed this summary table to `ggplot` and use `geom_col()` to plot the bars, with `geom_errorbar()` on top of that to plot the error bars.

To calculate error bar lengths we use a formula $\text{SE} = \frac{\text{SD}}{\sqrt{n}}$ where $n$ is the number of observations, SD is the standard deviation of the sample and SE is the standard error of the means of the sample. We can use the summary functions `sd()` to calculate the standard deviation, and `n()` to calculate $n$.

```{r}
penguins %>%
  drop_na() %>%
  group_by(species) %>%
  summarise(fl.mean = mean(flipper_length_mm), fl.se = sd(flipper_length_mm)/sqrt(n())) %>%
  ggplot(aes(x = species, y = fl.mean)) +
  geom_col() +
  geom_errorbar(aes(ymin=fl.mean-fl.se, ymax = fl.mean + fl.se),width=0.2) +
  labs(x = "Species",
       y = "Flipper length (mm)") +
  theme_bw() 
```

Now let's alter this code so that each bar has a different fill colour, and  remove the legend that then appears, since it is unnecessary?

```{r}
penguins %>%
  drop_na() %>%
  group_by(species) %>%
  summarise(fl.mean = mean(flipper_length_mm), fl.se = sd(flipper_length_mm)/sqrt(n())) %>%
  
  ggplot(aes(x = species, y = fl.mean, fill = species)) + # we have altered this line
  geom_col() +
  geom_errorbar(aes(ymin=fl.mean-fl.se, ymax = fl.mean + fl.se),width=0.2) +
  labs(x = "Species",
       y = "Flipper length (mm)") +
  theme_bw() +
  theme(legend.position = "none")
```

Now let us replace this colour scheme with nicer ones (not just nice, but also colour-blind friendly, perhaps) offered by the Brewer palettes. 

To do this we can add the line `scale_fill_brewer(palette = "Set2")`. Note: we use `scale_colour_brewer()` to alter the colours of points, like we did above, or the outline colour of bars, and use `scale_fill_brewer()` to alter the fill colour of bars. This is what we want to do here.

```{r}
penguins %>%
  drop_na() %>%
  group_by(species) %>%
  summarise(fl.mean = mean(flipper_length_mm), fl.se = sd(flipper_length_mm)/sqrt(n())) %>%
  
  ggplot(aes(x = species, y = fl.mean, fill = species)) + # we have altered this line
  geom_col() +
  geom_errorbar(aes(ymin=fl.mean-fl.se, ymax = fl.mean + fl.se),width=0.2) +
  labs(x = "Species",
       y = "Flipper length (mm)") +
  scale_fill_brewer(palette = "Set2") +
  theme_bw() +
  theme(legend.position = "none")
```


If you don't like the colours of the palette "Set2" you can try another one. To find out what palettes are available, remember, you can type `?scale_fill_brewer()` into the console pane then look at the help that appears in the Help pane (bottom right), and scroll down to the Palettes section.